---------------------------------------------------------------------------
--
--  (c) Copyright 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--
---------------------------------------------------------------------------
-- Description:
-- This is an example testbench for the pr_decoupler IP core.
-- The testbench has been generated by Vivado to accompany the IP core
-- instance you have generated.
--
-- This testbench is for demonstration purposes only.  See note below for
-- instructions on how to use it with the netlist created for your core.
--
-- See the pr_decoupler product guide for further information
-- about this core.
--
---------------------------------------------------------------------------
-- Using this testbench
--
-- This testbench instantiates your generated pr_decoupler core
-- instance named "prd".
--
-- Use Vivado's Run Simulation flow to run this testbench.  See the Vivado
-- documentation for details.
---------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library xil_defaultlib;

entity tb_prd is
end tb_prd;
 
architecture tb of tb_prd is

  -- Overall simulation phase control enumerated type and signal
  type t_sim_phase is (phase_pass_through,     -- Signals passing through the decoupler aren't decoupled
                       phase_in_transition,    -- Decoupling has changed but don't check; Give some time for the change to take effect
                       phase_decoupled         -- Signals passing through the decoupler are decoupled 
                       );
  signal sim_phase : t_sim_phase := phase_pass_through;

  constant CLOCK_PERIOD : time := 100 ns;
  signal clk: std_logic := '0'; 

  constant rp_add_CLOCK_PERIOD : time := 100 ns;
  signal rp_add_clk: std_logic := '0'; 

  constant rp_comp_CLOCK_PERIOD : time := 100 ns;
  signal rp_comp_clk: std_logic := '0'; 

  constant rp_dec_CLOCK_PERIOD : time := 100 ns;
  signal rp_dec_clk: std_logic := '0'; 

  constant rp_div_CLOCK_PERIOD : time := 100 ns;
  signal rp_div_clk: std_logic := '0'; 

  constant rp_inc_CLOCK_PERIOD : time := 100 ns;
  signal rp_inc_clk: std_logic := '0'; 

  constant rp_mod_CLOCK_PERIOD : time := 100 ns;
  signal rp_mod_clk: std_logic := '0'; 

  constant rp_mul_CLOCK_PERIOD : time := 100 ns;
  signal rp_mul_clk: std_logic := '0'; 

  constant rp_mux_CLOCK_PERIOD : time := 100 ns;
  signal rp_mux_clk: std_logic := '0'; 

  constant rp_reg_CLOCK_PERIOD : time := 100 ns;
  signal rp_reg_clk: std_logic := '0'; 

  constant rp_shl_CLOCK_PERIOD : time := 100 ns;
  signal rp_shl_clk: std_logic := '0'; 

  constant rp_shr_CLOCK_PERIOD : time := 100 ns;
  signal rp_shr_clk: std_logic := '0'; 

  constant rp_sub_CLOCK_PERIOD : time := 100 ns;
  signal rp_sub_clk: std_logic := '0'; 

  -- ---------------------------------------------------------------
  -- AXI LITE
  -- ---------------------------------------------------------------
  signal s_axi_reg_aresetn  : std_logic:= '1';
  signal s_axi_reg_awaddr   : std_logic_vector(0 downto 0) := (others => '0'); 
  signal s_axi_reg_awvalid  : std_logic := '0';
  signal s_axi_reg_awready  : std_logic := '0';
  signal s_axi_reg_wdata    : std_logic_vector(31 downto 0) := (others => '0'); 
  signal s_axi_reg_wvalid   : std_logic := '0';
  signal s_axi_reg_wready   : std_logic := '0';
  signal s_axi_reg_bresp    : std_logic_vector(1 downto 0) := (others => '0');
  signal s_axi_reg_bvalid   : std_logic := '0';
  signal s_axi_reg_bready   : std_logic := '1';
  signal s_axi_reg_araddr   : std_logic_vector(0 downto 0) := (others => '0'); 
  signal s_axi_reg_arvalid  : std_logic := '0';
  signal s_axi_reg_arready  : std_logic := '0';
  signal s_axi_reg_rdata    : std_logic_vector(31 downto 0) := (others => '0');
  signal s_axi_reg_rresp    : std_logic_vector(1 downto 0) := (others => '0');
  signal s_axi_reg_rvalid   : std_logic := '0';
  signal s_axi_reg_rready   : std_logic := '1';

  -- ---------------------------------------------------------------
  -- AXIS STATUS
  -- ---------------------------------------------------------------
  signal m_axis_status_tvalid : std_logic := '0';
  signal m_axis_status_tdata  : std_logic_vector(31 downto 0) := (others => '0');

  -- ---------------------------------------------------------------
  -- AXIS CONTROL
  -- ---------------------------------------------------------------
  signal s_axis_ctrl_aresetn : std_logic := '1';
  signal s_axis_ctrl_tvalid  : std_logic := '0';
  signal s_axis_ctrl_tready  : std_logic := '0';
  signal s_axis_ctrl_tdata   : std_logic_vector(31 downto 0) := (others => '0');

  -- ---------------------------------------------------------------
  -- SIGNAL STATUS
  -- ---------------------------------------------------------------
  signal decouple_status: std_logic;

  -- ---------------------------------------------------------------
  -- SIGNAL CONTROL
  -- ---------------------------------------------------------------
  signal decouple : std_logic := '0';
  signal  s_rp_add_TVALID : std_logic;
  signal rp_rp_add_TVALID : std_logic;
  signal  s_rp_add_TREADY : std_logic;
  signal rp_rp_add_TREADY : std_logic;
  signal  s_rp_add_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_add_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_add_TLAST : std_logic;
  signal rp_rp_add_TLAST : std_logic;
  signal  s_rp_comp_TVALID : std_logic;
  signal rp_rp_comp_TVALID : std_logic;
  signal  s_rp_comp_TREADY : std_logic;
  signal rp_rp_comp_TREADY : std_logic;
  signal  s_rp_comp_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_comp_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_comp_TLAST : std_logic;
  signal rp_rp_comp_TLAST : std_logic;
  signal  s_rp_dec_TVALID : std_logic;
  signal rp_rp_dec_TVALID : std_logic;
  signal  s_rp_dec_TREADY : std_logic;
  signal rp_rp_dec_TREADY : std_logic;
  signal  s_rp_dec_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_dec_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_dec_TLAST : std_logic;
  signal rp_rp_dec_TLAST : std_logic;
  signal  s_rp_div_TVALID : std_logic;
  signal rp_rp_div_TVALID : std_logic;
  signal  s_rp_div_TREADY : std_logic;
  signal rp_rp_div_TREADY : std_logic;
  signal  s_rp_div_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_div_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_div_TLAST : std_logic;
  signal rp_rp_div_TLAST : std_logic;
  signal  s_rp_inc_TVALID : std_logic;
  signal rp_rp_inc_TVALID : std_logic;
  signal  s_rp_inc_TREADY : std_logic;
  signal rp_rp_inc_TREADY : std_logic;
  signal  s_rp_inc_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_inc_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_inc_TLAST : std_logic;
  signal rp_rp_inc_TLAST : std_logic;
  signal  s_rp_mod_TVALID : std_logic;
  signal rp_rp_mod_TVALID : std_logic;
  signal  s_rp_mod_TREADY : std_logic;
  signal rp_rp_mod_TREADY : std_logic;
  signal  s_rp_mod_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_mod_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_mod_TLAST : std_logic;
  signal rp_rp_mod_TLAST : std_logic;
  signal  s_rp_mul_TVALID : std_logic;
  signal rp_rp_mul_TVALID : std_logic;
  signal  s_rp_mul_TREADY : std_logic;
  signal rp_rp_mul_TREADY : std_logic;
  signal  s_rp_mul_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_mul_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_mul_TLAST : std_logic;
  signal rp_rp_mul_TLAST : std_logic;
  signal  s_rp_mux_TVALID : std_logic;
  signal rp_rp_mux_TVALID : std_logic;
  signal  s_rp_mux_TREADY : std_logic;
  signal rp_rp_mux_TREADY : std_logic;
  signal  s_rp_mux_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_mux_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_mux_TLAST : std_logic;
  signal rp_rp_mux_TLAST : std_logic;
  signal  s_rp_reg_TVALID : std_logic;
  signal rp_rp_reg_TVALID : std_logic;
  signal  s_rp_reg_TREADY : std_logic;
  signal rp_rp_reg_TREADY : std_logic;
  signal  s_rp_reg_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_reg_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_reg_TLAST : std_logic;
  signal rp_rp_reg_TLAST : std_logic;
  signal  s_rp_shl_TVALID : std_logic;
  signal rp_rp_shl_TVALID : std_logic;
  signal  s_rp_shl_TREADY : std_logic;
  signal rp_rp_shl_TREADY : std_logic;
  signal  s_rp_shl_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_shl_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_shl_TLAST : std_logic;
  signal rp_rp_shl_TLAST : std_logic;
  signal  s_rp_shr_TVALID : std_logic;
  signal rp_rp_shr_TVALID : std_logic;
  signal  s_rp_shr_TREADY : std_logic;
  signal rp_rp_shr_TREADY : std_logic;
  signal  s_rp_shr_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_shr_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_shr_TLAST : std_logic;
  signal rp_rp_shr_TLAST : std_logic;
  signal  s_rp_sub_TVALID : std_logic;
  signal rp_rp_sub_TVALID : std_logic;
  signal  s_rp_sub_TREADY : std_logic;
  signal rp_rp_sub_TREADY : std_logic;
  signal  s_rp_sub_TDATA : std_logic_vector(31 downto 0);
  signal rp_rp_sub_TDATA : std_logic_vector(31 downto 0);
  signal  s_rp_sub_TLAST : std_logic;
  signal rp_rp_sub_TLAST : std_logic;
begin
  dut : entity xil_defaultlib.prd
    port map (
      
      -- ---------------------------------------------------------------
      -- AXI LITE
      -- ---------------------------------------------------------------
      s_axi_reg_aresetn => s_axi_reg_aresetn,
      s_axi_reg_awaddr  => s_axi_reg_awaddr ,
      s_axi_reg_awvalid => s_axi_reg_awvalid,
      s_axi_reg_awready => s_axi_reg_awready,
      s_axi_reg_wdata   => s_axi_reg_wdata  ,
      s_axi_reg_wvalid  => s_axi_reg_wvalid ,
      s_axi_reg_wready  => s_axi_reg_wready ,
      s_axi_reg_bresp   => s_axi_reg_bresp  ,
      s_axi_reg_bvalid  => s_axi_reg_bvalid ,
      s_axi_reg_bready  => s_axi_reg_bready ,
      s_axi_reg_araddr  => s_axi_reg_araddr ,
      s_axi_reg_arvalid => s_axi_reg_arvalid,
      s_axi_reg_arready => s_axi_reg_arready,
      s_axi_reg_rdata   => s_axi_reg_rdata  ,
      s_axi_reg_rresp   => s_axi_reg_rresp  ,
      s_axi_reg_rvalid  => s_axi_reg_rvalid ,
      s_axi_reg_rready  => s_axi_reg_rready ,
      
      -- ---------------------------------------------------------------
      -- CLOCK
      -- ---------------------------------------------------------------
      aclk => clk,
      -- ---------------------------------------------------------------
      -- AXIS STATUS
      -- ---------------------------------------------------------------
      
      m_axis_status_tvalid => m_axis_status_tvalid,
      m_axis_status_tdata  => m_axis_status_tdata,
      
      -- ---------------------------------------------------------------
      -- AXIS CONTROL
      -- ---------------------------------------------------------------
      s_axis_ctrl_aresetn => s_axis_ctrl_aresetn,
      s_axis_ctrl_tvalid  => s_axis_ctrl_tvalid ,
      s_axis_ctrl_tready  => s_axis_ctrl_tready ,
      s_axis_ctrl_tdata   => s_axis_ctrl_tdata  ,
      
      -- ---------------------------------------------------------------
      -- SIGNAL STATUS
      -- ---------------------------------------------------------------
      decouple_status => decouple_status,
      
      -- ---------------------------------------------------------------
      -- SIGNAL CONTROL
      -- ---------------------------------------------------------------
      decouple => decouple,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_add
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_add_ref_clk => rp_add_clk,
      s_rp_add_TVALID  =>  s_rp_add_TVALID,
      rp_rp_add_TVALID => rp_rp_add_TVALID,
      s_rp_add_TREADY  =>  s_rp_add_TREADY,
      rp_rp_add_TREADY => rp_rp_add_TREADY,
      s_rp_add_TDATA  =>  s_rp_add_TDATA,
      rp_rp_add_TDATA => rp_rp_add_TDATA,
      s_rp_add_TLAST  =>  s_rp_add_TLAST,
      rp_rp_add_TLAST => rp_rp_add_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_comp
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_comp_ref_clk => rp_comp_clk,
      s_rp_comp_TVALID  =>  s_rp_comp_TVALID,
      rp_rp_comp_TVALID => rp_rp_comp_TVALID,
      s_rp_comp_TREADY  =>  s_rp_comp_TREADY,
      rp_rp_comp_TREADY => rp_rp_comp_TREADY,
      s_rp_comp_TDATA  =>  s_rp_comp_TDATA,
      rp_rp_comp_TDATA => rp_rp_comp_TDATA,
      s_rp_comp_TLAST  =>  s_rp_comp_TLAST,
      rp_rp_comp_TLAST => rp_rp_comp_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_dec
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_dec_ref_clk => rp_dec_clk,
      s_rp_dec_TVALID  =>  s_rp_dec_TVALID,
      rp_rp_dec_TVALID => rp_rp_dec_TVALID,
      s_rp_dec_TREADY  =>  s_rp_dec_TREADY,
      rp_rp_dec_TREADY => rp_rp_dec_TREADY,
      s_rp_dec_TDATA  =>  s_rp_dec_TDATA,
      rp_rp_dec_TDATA => rp_rp_dec_TDATA,
      s_rp_dec_TLAST  =>  s_rp_dec_TLAST,
      rp_rp_dec_TLAST => rp_rp_dec_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_div
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_div_ref_clk => rp_div_clk,
      s_rp_div_TVALID  =>  s_rp_div_TVALID,
      rp_rp_div_TVALID => rp_rp_div_TVALID,
      s_rp_div_TREADY  =>  s_rp_div_TREADY,
      rp_rp_div_TREADY => rp_rp_div_TREADY,
      s_rp_div_TDATA  =>  s_rp_div_TDATA,
      rp_rp_div_TDATA => rp_rp_div_TDATA,
      s_rp_div_TLAST  =>  s_rp_div_TLAST,
      rp_rp_div_TLAST => rp_rp_div_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_inc
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_inc_ref_clk => rp_inc_clk,
      s_rp_inc_TVALID  =>  s_rp_inc_TVALID,
      rp_rp_inc_TVALID => rp_rp_inc_TVALID,
      s_rp_inc_TREADY  =>  s_rp_inc_TREADY,
      rp_rp_inc_TREADY => rp_rp_inc_TREADY,
      s_rp_inc_TDATA  =>  s_rp_inc_TDATA,
      rp_rp_inc_TDATA => rp_rp_inc_TDATA,
      s_rp_inc_TLAST  =>  s_rp_inc_TLAST,
      rp_rp_inc_TLAST => rp_rp_inc_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_mod
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_mod_ref_clk => rp_mod_clk,
      s_rp_mod_TVALID  =>  s_rp_mod_TVALID,
      rp_rp_mod_TVALID => rp_rp_mod_TVALID,
      s_rp_mod_TREADY  =>  s_rp_mod_TREADY,
      rp_rp_mod_TREADY => rp_rp_mod_TREADY,
      s_rp_mod_TDATA  =>  s_rp_mod_TDATA,
      rp_rp_mod_TDATA => rp_rp_mod_TDATA,
      s_rp_mod_TLAST  =>  s_rp_mod_TLAST,
      rp_rp_mod_TLAST => rp_rp_mod_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_mul
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_mul_ref_clk => rp_mul_clk,
      s_rp_mul_TVALID  =>  s_rp_mul_TVALID,
      rp_rp_mul_TVALID => rp_rp_mul_TVALID,
      s_rp_mul_TREADY  =>  s_rp_mul_TREADY,
      rp_rp_mul_TREADY => rp_rp_mul_TREADY,
      s_rp_mul_TDATA  =>  s_rp_mul_TDATA,
      rp_rp_mul_TDATA => rp_rp_mul_TDATA,
      s_rp_mul_TLAST  =>  s_rp_mul_TLAST,
      rp_rp_mul_TLAST => rp_rp_mul_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_mux
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_mux_ref_clk => rp_mux_clk,
      s_rp_mux_TVALID  =>  s_rp_mux_TVALID,
      rp_rp_mux_TVALID => rp_rp_mux_TVALID,
      s_rp_mux_TREADY  =>  s_rp_mux_TREADY,
      rp_rp_mux_TREADY => rp_rp_mux_TREADY,
      s_rp_mux_TDATA  =>  s_rp_mux_TDATA,
      rp_rp_mux_TDATA => rp_rp_mux_TDATA,
      s_rp_mux_TLAST  =>  s_rp_mux_TLAST,
      rp_rp_mux_TLAST => rp_rp_mux_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_reg
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_reg_ref_clk => rp_reg_clk,
      s_rp_reg_TVALID  =>  s_rp_reg_TVALID,
      rp_rp_reg_TVALID => rp_rp_reg_TVALID,
      s_rp_reg_TREADY  =>  s_rp_reg_TREADY,
      rp_rp_reg_TREADY => rp_rp_reg_TREADY,
      s_rp_reg_TDATA  =>  s_rp_reg_TDATA,
      rp_rp_reg_TDATA => rp_rp_reg_TDATA,
      s_rp_reg_TLAST  =>  s_rp_reg_TLAST,
      rp_rp_reg_TLAST => rp_rp_reg_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_shl
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_shl_ref_clk => rp_shl_clk,
      s_rp_shl_TVALID  =>  s_rp_shl_TVALID,
      rp_rp_shl_TVALID => rp_rp_shl_TVALID,
      s_rp_shl_TREADY  =>  s_rp_shl_TREADY,
      rp_rp_shl_TREADY => rp_rp_shl_TREADY,
      s_rp_shl_TDATA  =>  s_rp_shl_TDATA,
      rp_rp_shl_TDATA => rp_rp_shl_TDATA,
      s_rp_shl_TLAST  =>  s_rp_shl_TLAST,
      rp_rp_shl_TLAST => rp_rp_shl_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_shr
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_shr_ref_clk => rp_shr_clk,
      s_rp_shr_TVALID  =>  s_rp_shr_TVALID,
      rp_rp_shr_TVALID => rp_rp_shr_TVALID,
      s_rp_shr_TREADY  =>  s_rp_shr_TREADY,
      rp_rp_shr_TREADY => rp_rp_shr_TREADY,
      s_rp_shr_TDATA  =>  s_rp_shr_TDATA,
      rp_rp_shr_TDATA => rp_rp_shr_TDATA,
      s_rp_shr_TLAST  =>  s_rp_shr_TLAST,
      rp_rp_shr_TLAST => rp_rp_shr_TLAST,
      
      -- ---------------------------------------------------------------
      -- Interface      = rp_sub
      -- vlnv           = xilinx.com:interface:axis_rtl:1.0
      -- mode           = master
      -- static_mode    = master
      -- cdc_stages     = 2
      -- ---------------------------------------------------------------
      rp_sub_ref_clk => rp_sub_clk,
      s_rp_sub_TVALID  =>  s_rp_sub_TVALID,
      rp_rp_sub_TVALID => rp_rp_sub_TVALID,
      s_rp_sub_TREADY  =>  s_rp_sub_TREADY,
      rp_rp_sub_TREADY => rp_rp_sub_TREADY,
      s_rp_sub_TDATA  =>  s_rp_sub_TDATA,
      rp_rp_sub_TDATA => rp_rp_sub_TDATA,
      s_rp_sub_TLAST  =>  s_rp_sub_TLAST,
      rp_rp_sub_TLAST => rp_rp_sub_TLAST
    );

  clock_gen : process
  begin
    clk <= '0';
    wait for CLOCK_PERIOD;
    loop
      clk <= '0';
      wait for CLOCK_PERIOD/2;
      clk <= '1';
      wait for CLOCK_PERIOD/2;
    end loop;
  end process clock_gen;

  rp_add_clock_gen : process
  begin
    rp_add_clk <= '0';
    wait for rp_add_CLOCK_PERIOD;
    loop
      rp_add_clk <= '0';
      wait for rp_add_CLOCK_PERIOD/2;
      rp_add_clk <= '1';
      wait for rp_add_CLOCK_PERIOD/2;
    end loop;
  end process rp_add_clock_gen;

  rp_comp_clock_gen : process
  begin
    rp_comp_clk <= '0';
    wait for rp_comp_CLOCK_PERIOD;
    loop
      rp_comp_clk <= '0';
      wait for rp_comp_CLOCK_PERIOD/2;
      rp_comp_clk <= '1';
      wait for rp_comp_CLOCK_PERIOD/2;
    end loop;
  end process rp_comp_clock_gen;

  rp_dec_clock_gen : process
  begin
    rp_dec_clk <= '0';
    wait for rp_dec_CLOCK_PERIOD;
    loop
      rp_dec_clk <= '0';
      wait for rp_dec_CLOCK_PERIOD/2;
      rp_dec_clk <= '1';
      wait for rp_dec_CLOCK_PERIOD/2;
    end loop;
  end process rp_dec_clock_gen;

  rp_div_clock_gen : process
  begin
    rp_div_clk <= '0';
    wait for rp_div_CLOCK_PERIOD;
    loop
      rp_div_clk <= '0';
      wait for rp_div_CLOCK_PERIOD/2;
      rp_div_clk <= '1';
      wait for rp_div_CLOCK_PERIOD/2;
    end loop;
  end process rp_div_clock_gen;

  rp_inc_clock_gen : process
  begin
    rp_inc_clk <= '0';
    wait for rp_inc_CLOCK_PERIOD;
    loop
      rp_inc_clk <= '0';
      wait for rp_inc_CLOCK_PERIOD/2;
      rp_inc_clk <= '1';
      wait for rp_inc_CLOCK_PERIOD/2;
    end loop;
  end process rp_inc_clock_gen;

  rp_mod_clock_gen : process
  begin
    rp_mod_clk <= '0';
    wait for rp_mod_CLOCK_PERIOD;
    loop
      rp_mod_clk <= '0';
      wait for rp_mod_CLOCK_PERIOD/2;
      rp_mod_clk <= '1';
      wait for rp_mod_CLOCK_PERIOD/2;
    end loop;
  end process rp_mod_clock_gen;

  rp_mul_clock_gen : process
  begin
    rp_mul_clk <= '0';
    wait for rp_mul_CLOCK_PERIOD;
    loop
      rp_mul_clk <= '0';
      wait for rp_mul_CLOCK_PERIOD/2;
      rp_mul_clk <= '1';
      wait for rp_mul_CLOCK_PERIOD/2;
    end loop;
  end process rp_mul_clock_gen;

  rp_mux_clock_gen : process
  begin
    rp_mux_clk <= '0';
    wait for rp_mux_CLOCK_PERIOD;
    loop
      rp_mux_clk <= '0';
      wait for rp_mux_CLOCK_PERIOD/2;
      rp_mux_clk <= '1';
      wait for rp_mux_CLOCK_PERIOD/2;
    end loop;
  end process rp_mux_clock_gen;

  rp_reg_clock_gen : process
  begin
    rp_reg_clk <= '0';
    wait for rp_reg_CLOCK_PERIOD;
    loop
      rp_reg_clk <= '0';
      wait for rp_reg_CLOCK_PERIOD/2;
      rp_reg_clk <= '1';
      wait for rp_reg_CLOCK_PERIOD/2;
    end loop;
  end process rp_reg_clock_gen;

  rp_shl_clock_gen : process
  begin
    rp_shl_clk <= '0';
    wait for rp_shl_CLOCK_PERIOD;
    loop
      rp_shl_clk <= '0';
      wait for rp_shl_CLOCK_PERIOD/2;
      rp_shl_clk <= '1';
      wait for rp_shl_CLOCK_PERIOD/2;
    end loop;
  end process rp_shl_clock_gen;

  rp_shr_clock_gen : process
  begin
    rp_shr_clk <= '0';
    wait for rp_shr_CLOCK_PERIOD;
    loop
      rp_shr_clk <= '0';
      wait for rp_shr_CLOCK_PERIOD/2;
      rp_shr_clk <= '1';
      wait for rp_shr_CLOCK_PERIOD/2;
    end loop;
  end process rp_shr_clock_gen;

  rp_sub_clock_gen : process
  begin
    rp_sub_clk <= '0';
    wait for rp_sub_CLOCK_PERIOD;
    loop
      rp_sub_clk <= '0';
      wait for rp_sub_CLOCK_PERIOD/2;
      rp_sub_clk <= '1';
      wait for rp_sub_CLOCK_PERIOD/2;
    end loop;
  end process rp_sub_clock_gen;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_add_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_add_TVALID_driver : process (rp_add_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_add_clk) then
        rp_rp_add_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TVALID_driver;

  p_rp_add_TVALID_checker : process (rp_add_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_add_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_add_TVALID)) then
          report "rp_add_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_add_TVALID)), 4) then
          report "rp_add_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_add_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_add_TREADY_driver : process (rp_add_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_add_clk) then
        s_rp_add_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TREADY_driver;

  p_rp_add_TREADY_checker : process (rp_add_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_add_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_add_TREADY)) then
          report "rp_add_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_add_TREADY)), 4) then
          report "rp_add_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_add_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_add_TDATA_driver : process (rp_add_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_add_clk) then
        rp_rp_add_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_add_TDATA_driver;

  p_rp_add_TDATA_checker : process (rp_add_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_add_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_add_TDATA ) then
          report "rp_add_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_add_TDATA) then
          report "rp_add_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_add_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_add_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_add_TLAST_driver : process (rp_add_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_add_clk) then
        rp_rp_add_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TLAST_driver;

  p_rp_add_TLAST_checker : process (rp_add_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_add_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_add_TLAST)) then
          report "rp_add_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_add_TLAST)), 4) then
          report "rp_add_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_add_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_comp_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_comp_TVALID_driver : process (rp_comp_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_comp_clk) then
        rp_rp_comp_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TVALID_driver;

  p_rp_comp_TVALID_checker : process (rp_comp_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_comp_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_comp_TVALID)) then
          report "rp_comp_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_comp_TVALID)), 4) then
          report "rp_comp_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_comp_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_comp_TREADY_driver : process (rp_comp_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_comp_clk) then
        s_rp_comp_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TREADY_driver;

  p_rp_comp_TREADY_checker : process (rp_comp_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_comp_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_comp_TREADY)) then
          report "rp_comp_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_comp_TREADY)), 4) then
          report "rp_comp_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_comp_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_comp_TDATA_driver : process (rp_comp_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_comp_clk) then
        rp_rp_comp_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_comp_TDATA_driver;

  p_rp_comp_TDATA_checker : process (rp_comp_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_comp_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_comp_TDATA ) then
          report "rp_comp_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_comp_TDATA) then
          report "rp_comp_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_comp_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_comp_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_comp_TLAST_driver : process (rp_comp_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_comp_clk) then
        rp_rp_comp_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TLAST_driver;

  p_rp_comp_TLAST_checker : process (rp_comp_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_comp_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_comp_TLAST)) then
          report "rp_comp_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_comp_TLAST)), 4) then
          report "rp_comp_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_comp_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_dec_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_dec_TVALID_driver : process (rp_dec_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_dec_clk) then
        rp_rp_dec_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TVALID_driver;

  p_rp_dec_TVALID_checker : process (rp_dec_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_dec_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_dec_TVALID)) then
          report "rp_dec_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_dec_TVALID)), 4) then
          report "rp_dec_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_dec_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_dec_TREADY_driver : process (rp_dec_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_dec_clk) then
        s_rp_dec_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TREADY_driver;

  p_rp_dec_TREADY_checker : process (rp_dec_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_dec_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_dec_TREADY)) then
          report "rp_dec_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_dec_TREADY)), 4) then
          report "rp_dec_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_dec_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_dec_TDATA_driver : process (rp_dec_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_dec_clk) then
        rp_rp_dec_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_dec_TDATA_driver;

  p_rp_dec_TDATA_checker : process (rp_dec_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_dec_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_dec_TDATA ) then
          report "rp_dec_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_dec_TDATA) then
          report "rp_dec_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_dec_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_dec_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_dec_TLAST_driver : process (rp_dec_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_dec_clk) then
        rp_rp_dec_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TLAST_driver;

  p_rp_dec_TLAST_checker : process (rp_dec_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_dec_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_dec_TLAST)) then
          report "rp_dec_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_dec_TLAST)), 4) then
          report "rp_dec_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_dec_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_div_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_div_TVALID_driver : process (rp_div_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_div_clk) then
        rp_rp_div_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TVALID_driver;

  p_rp_div_TVALID_checker : process (rp_div_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_div_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_div_TVALID)) then
          report "rp_div_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_div_TVALID)), 4) then
          report "rp_div_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_div_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_div_TREADY_driver : process (rp_div_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_div_clk) then
        s_rp_div_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TREADY_driver;

  p_rp_div_TREADY_checker : process (rp_div_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_div_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_div_TREADY)) then
          report "rp_div_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_div_TREADY)), 4) then
          report "rp_div_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_div_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_div_TDATA_driver : process (rp_div_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_div_clk) then
        rp_rp_div_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_div_TDATA_driver;

  p_rp_div_TDATA_checker : process (rp_div_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_div_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_div_TDATA ) then
          report "rp_div_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_div_TDATA) then
          report "rp_div_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_div_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_div_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_div_TLAST_driver : process (rp_div_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_div_clk) then
        rp_rp_div_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TLAST_driver;

  p_rp_div_TLAST_checker : process (rp_div_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_div_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_div_TLAST)) then
          report "rp_div_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_div_TLAST)), 4) then
          report "rp_div_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_div_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_inc_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_inc_TVALID_driver : process (rp_inc_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_inc_clk) then
        rp_rp_inc_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TVALID_driver;

  p_rp_inc_TVALID_checker : process (rp_inc_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_inc_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_inc_TVALID)) then
          report "rp_inc_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_inc_TVALID)), 4) then
          report "rp_inc_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_inc_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_inc_TREADY_driver : process (rp_inc_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_inc_clk) then
        s_rp_inc_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TREADY_driver;

  p_rp_inc_TREADY_checker : process (rp_inc_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_inc_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_inc_TREADY)) then
          report "rp_inc_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_inc_TREADY)), 4) then
          report "rp_inc_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_inc_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_inc_TDATA_driver : process (rp_inc_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_inc_clk) then
        rp_rp_inc_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_inc_TDATA_driver;

  p_rp_inc_TDATA_checker : process (rp_inc_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_inc_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_inc_TDATA ) then
          report "rp_inc_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_inc_TDATA) then
          report "rp_inc_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_inc_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_inc_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_inc_TLAST_driver : process (rp_inc_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_inc_clk) then
        rp_rp_inc_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TLAST_driver;

  p_rp_inc_TLAST_checker : process (rp_inc_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_inc_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_inc_TLAST)) then
          report "rp_inc_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_inc_TLAST)), 4) then
          report "rp_inc_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_inc_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mod_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_mod_TVALID_driver : process (rp_mod_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mod_clk) then
        rp_rp_mod_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TVALID_driver;

  p_rp_mod_TVALID_checker : process (rp_mod_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mod_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mod_TVALID)) then
          report "rp_mod_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mod_TVALID)), 4) then
          report "rp_mod_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mod_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_mod_TREADY_driver : process (rp_mod_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mod_clk) then
        s_rp_mod_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TREADY_driver;

  p_rp_mod_TREADY_checker : process (rp_mod_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mod_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_mod_TREADY)) then
          report "rp_mod_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_mod_TREADY)), 4) then
          report "rp_mod_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mod_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_mod_TDATA_driver : process (rp_mod_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mod_clk) then
        rp_rp_mod_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mod_TDATA_driver;

  p_rp_mod_TDATA_checker : process (rp_mod_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mod_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_mod_TDATA ) then
          report "rp_mod_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_mod_TDATA) then
          report "rp_mod_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mod_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mod_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_mod_TLAST_driver : process (rp_mod_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mod_clk) then
        rp_rp_mod_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TLAST_driver;

  p_rp_mod_TLAST_checker : process (rp_mod_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mod_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mod_TLAST)) then
          report "rp_mod_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mod_TLAST)), 4) then
          report "rp_mod_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mod_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mul_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_mul_TVALID_driver : process (rp_mul_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mul_clk) then
        rp_rp_mul_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TVALID_driver;

  p_rp_mul_TVALID_checker : process (rp_mul_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mul_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mul_TVALID)) then
          report "rp_mul_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mul_TVALID)), 4) then
          report "rp_mul_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mul_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_mul_TREADY_driver : process (rp_mul_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mul_clk) then
        s_rp_mul_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TREADY_driver;

  p_rp_mul_TREADY_checker : process (rp_mul_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mul_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_mul_TREADY)) then
          report "rp_mul_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_mul_TREADY)), 4) then
          report "rp_mul_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mul_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_mul_TDATA_driver : process (rp_mul_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mul_clk) then
        rp_rp_mul_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mul_TDATA_driver;

  p_rp_mul_TDATA_checker : process (rp_mul_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mul_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_mul_TDATA ) then
          report "rp_mul_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_mul_TDATA) then
          report "rp_mul_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mul_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mul_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_mul_TLAST_driver : process (rp_mul_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mul_clk) then
        rp_rp_mul_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TLAST_driver;

  p_rp_mul_TLAST_checker : process (rp_mul_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mul_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mul_TLAST)) then
          report "rp_mul_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mul_TLAST)), 4) then
          report "rp_mul_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mul_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mux_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_mux_TVALID_driver : process (rp_mux_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mux_clk) then
        rp_rp_mux_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TVALID_driver;

  p_rp_mux_TVALID_checker : process (rp_mux_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mux_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mux_TVALID)) then
          report "rp_mux_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mux_TVALID)), 4) then
          report "rp_mux_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mux_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_mux_TREADY_driver : process (rp_mux_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mux_clk) then
        s_rp_mux_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TREADY_driver;

  p_rp_mux_TREADY_checker : process (rp_mux_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_mux_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_mux_TREADY)) then
          report "rp_mux_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_mux_TREADY)), 4) then
          report "rp_mux_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mux_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_mux_TDATA_driver : process (rp_mux_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mux_clk) then
        rp_rp_mux_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mux_TDATA_driver;

  p_rp_mux_TDATA_checker : process (rp_mux_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mux_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_mux_TDATA ) then
          report "rp_mux_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_mux_TDATA) then
          report "rp_mux_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_mux_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_mux_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_mux_TLAST_driver : process (rp_mux_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_mux_clk) then
        rp_rp_mux_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TLAST_driver;

  p_rp_mux_TLAST_checker : process (rp_mux_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_mux_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_mux_TLAST)) then
          report "rp_mux_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_mux_TLAST)), 4) then
          report "rp_mux_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_mux_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_reg_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_reg_TVALID_driver : process (rp_reg_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_reg_clk) then
        rp_rp_reg_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TVALID_driver;

  p_rp_reg_TVALID_checker : process (rp_reg_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_reg_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_reg_TVALID)) then
          report "rp_reg_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_reg_TVALID)), 4) then
          report "rp_reg_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_reg_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_reg_TREADY_driver : process (rp_reg_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_reg_clk) then
        s_rp_reg_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TREADY_driver;

  p_rp_reg_TREADY_checker : process (rp_reg_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_reg_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_reg_TREADY)) then
          report "rp_reg_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_reg_TREADY)), 4) then
          report "rp_reg_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_reg_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_reg_TDATA_driver : process (rp_reg_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_reg_clk) then
        rp_rp_reg_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_reg_TDATA_driver;

  p_rp_reg_TDATA_checker : process (rp_reg_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_reg_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_reg_TDATA ) then
          report "rp_reg_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_reg_TDATA) then
          report "rp_reg_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_reg_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_reg_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_reg_TLAST_driver : process (rp_reg_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_reg_clk) then
        rp_rp_reg_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TLAST_driver;

  p_rp_reg_TLAST_checker : process (rp_reg_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_reg_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_reg_TLAST)) then
          report "rp_reg_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_reg_TLAST)), 4) then
          report "rp_reg_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_reg_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shl_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_shl_TVALID_driver : process (rp_shl_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shl_clk) then
        rp_rp_shl_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TVALID_driver;

  p_rp_shl_TVALID_checker : process (rp_shl_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_shl_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_shl_TVALID)) then
          report "rp_shl_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_shl_TVALID)), 4) then
          report "rp_shl_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shl_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_shl_TREADY_driver : process (rp_shl_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shl_clk) then
        s_rp_shl_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TREADY_driver;

  p_rp_shl_TREADY_checker : process (rp_shl_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_shl_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_shl_TREADY)) then
          report "rp_shl_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_shl_TREADY)), 4) then
          report "rp_shl_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shl_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_shl_TDATA_driver : process (rp_shl_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shl_clk) then
        rp_rp_shl_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_shl_TDATA_driver;

  p_rp_shl_TDATA_checker : process (rp_shl_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_shl_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_shl_TDATA ) then
          report "rp_shl_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_shl_TDATA) then
          report "rp_shl_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_shl_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shl_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_shl_TLAST_driver : process (rp_shl_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shl_clk) then
        rp_rp_shl_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TLAST_driver;

  p_rp_shl_TLAST_checker : process (rp_shl_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_shl_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_shl_TLAST)) then
          report "rp_shl_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_shl_TLAST)), 4) then
          report "rp_shl_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shl_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shr_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_shr_TVALID_driver : process (rp_shr_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shr_clk) then
        rp_rp_shr_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TVALID_driver;

  p_rp_shr_TVALID_checker : process (rp_shr_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_shr_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_shr_TVALID)) then
          report "rp_shr_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_shr_TVALID)), 4) then
          report "rp_shr_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shr_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_shr_TREADY_driver : process (rp_shr_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shr_clk) then
        s_rp_shr_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TREADY_driver;

  p_rp_shr_TREADY_checker : process (rp_shr_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_shr_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_shr_TREADY)) then
          report "rp_shr_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_shr_TREADY)), 4) then
          report "rp_shr_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shr_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_shr_TDATA_driver : process (rp_shr_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shr_clk) then
        rp_rp_shr_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_shr_TDATA_driver;

  p_rp_shr_TDATA_checker : process (rp_shr_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_shr_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_shr_TDATA ) then
          report "rp_shr_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_shr_TDATA) then
          report "rp_shr_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_shr_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_shr_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_shr_TLAST_driver : process (rp_shr_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_shr_clk) then
        rp_rp_shr_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TLAST_driver;

  p_rp_shr_TLAST_checker : process (rp_shr_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_shr_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_shr_TLAST)) then
          report "rp_shr_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_shr_TLAST)), 4) then
          report "rp_shr_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_shr_TLAST_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_sub_TVALID
  -- ------------------------------------------------------------------------------------
  p_rp_sub_TVALID_driver : process (rp_sub_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_sub_clk) then
        rp_rp_sub_TVALID <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TVALID_driver;

  p_rp_sub_TVALID_checker : process (rp_sub_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_sub_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_sub_TVALID)) then
          report "rp_sub_TVALID mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_sub_TVALID)), 4) then
          report "rp_sub_TVALID mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TVALID_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_sub_TREADY
  -- ------------------------------------------------------------------------------------
  p_rp_sub_TREADY_driver : process (rp_sub_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_sub_clk) then
        s_rp_sub_TREADY <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TREADY_driver;

  p_rp_sub_TREADY_checker : process (rp_sub_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '1';
  begin
    if falling_edge(rp_sub_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (rp_rp_sub_TREADY)) then
          report "rp_sub_TREADY mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (rp_rp_sub_TREADY)), 4) then
          report "rp_sub_TREADY mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TREADY_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_sub_TDATA
  -- ------------------------------------------------------------------------------------
  p_rp_sub_TDATA_driver : process (rp_sub_clk)
    variable v_data : unsigned(32-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_sub_clk) then
        rp_rp_sub_TDATA <= std_logic_vector(v_data);
       v_data := v_data + to_unsigned(1, 32);
    end if;
  end process p_rp_sub_TDATA_driver;

  p_rp_sub_TDATA_checker : process (rp_sub_clk)
    variable v_expected_data : unsigned(32-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_sub_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned( s_rp_sub_TDATA ) then
          report "rp_sub_TDATA mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
        if resize(x"0", 32) /= unsigned(s_rp_sub_TDATA) then
          report "rp_sub_TDATA mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 32);
    end if;
  end process p_rp_sub_TDATA_checker;

  -- ------------------------------------------------------------------------------------
  -- Drive and Check rp_sub_TLAST
  -- ------------------------------------------------------------------------------------
  p_rp_sub_TLAST_driver : process (rp_sub_clk)
    variable v_data : unsigned(1-1 downto 0) := (others => '0');
  begin
    if rising_edge(rp_sub_clk) then
        rp_rp_sub_TLAST <= std_logic(v_data(0));
       v_data := v_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TLAST_driver;

  p_rp_sub_TLAST_checker : process (rp_sub_clk)
    variable v_expected_data : unsigned(1-1 downto 0) := (others => '0');
    constant is_decoupled: std_logic := '0';
  begin
    if falling_edge(rp_sub_clk) then
      if sim_phase = phase_pass_through or is_decoupled = '0' then
        if v_expected_data /= unsigned'("" & (s_rp_sub_TLAST)) then
          report "rp_sub_TLAST mismatch in passthrough mode" severity ERROR;
        end if; 
      elsif sim_phase = phase_decoupled then
       if x"0" /= resize(unsigned'("" & (s_rp_sub_TLAST)), 4) then
          report "rp_sub_TLAST mismatch in decouple mode" severity ERROR;
        end if; 
      end if;
      v_expected_data := v_expected_data + to_unsigned(1, 1);
    end if;
  end process p_rp_sub_TLAST_checker;


  -----------------------------------------------------------------------
  -- Simulation control
  -- Run a series of demonstrations, each in a separate test phase
  -- This process controls all other stimuli processes
  -----------------------------------------------------------------------
  sim_control : process
  begin
    -- Drive simulation control synchronous to the rising edge of the clock
    wait until rising_edge(clk);

    -- -------------------------------------------------------
    -- Start with decoupling off
    -- -------------------------------------------------------
    sim_phase <= phase_pass_through;
    wait for 120 * CLOCK_PERIOD;

    -- -------------------------------------------------------
    -- Turn decoupling on
    -- -------------------------------------------------------
    sim_phase <= phase_in_transition;

    -- Using Signal Control interface
    decouple <= '1';
    wait for 10 * CLOCK_PERIOD;

    -- Using the AXIS Control interface
    s_axis_ctrl_tvalid   <= '1';
    s_axis_ctrl_tdata(0) <= '1';
    wait for 1 * CLOCK_PERIOD;

    s_axis_ctrl_tvalid   <= '0';
    wait for 1 * CLOCK_PERIOD;

    -- Using the AXI_LITE Interface
    s_axi_reg_awaddr   <= "0";
    s_axi_reg_awvalid  <= '1';
    s_axi_reg_wdata(0) <= '1';
    s_axi_reg_wvalid   <= '1';

    wait until s_axi_reg_awready = '1' AND s_axi_reg_wready = '1';
    wait for 1 * CLOCK_PERIOD;

    s_axi_reg_awvalid <= '0';
    s_axi_reg_wvalid  <= '0';
    wait for 1 * CLOCK_PERIOD;

    wait for 10 * CLOCK_PERIOD;
    sim_phase <= phase_decoupled;
    wait for 120 * CLOCK_PERIOD;

    -- -------------------------------------------------------
    -- Turn decoupling off
    -- -------------------------------------------------------
    sim_phase <= phase_in_transition;

    -- Using Signal Control interface
    decouple <= '0';
    wait for 10 * CLOCK_PERIOD;

    -- Using the AXIS Control interface
    s_axis_ctrl_tvalid   <= '1';
    s_axis_ctrl_tdata(0) <= '0';
    wait for 1 * CLOCK_PERIOD;

    s_axis_ctrl_tvalid   <= '0';
    wait for 1 * CLOCK_PERIOD;

    -- Using the AXI_LITE Interface
    s_axi_reg_awaddr   <= "0";
    s_axi_reg_awvalid  <= '1';
    s_axi_reg_wdata(0) <= '0';
    s_axi_reg_wvalid   <= '1';

    wait until s_axi_reg_awready = '1' AND s_axi_reg_wready = '1';
    wait for 1 * CLOCK_PERIOD;

    s_axi_reg_awvalid <= '0';
    s_axi_reg_wvalid  <= '0';
    wait for 1 * CLOCK_PERIOD;

    wait for 10 * CLOCK_PERIOD;

    sim_phase <= phase_pass_through;
    wait for 120 * CLOCK_PERIOD;

    -- End of simulation
    wait for CLOCK_PERIOD;
    report "Not a real failure. Test completed successfully." severity failure;
    wait;
  end process sim_control;

end tb;
